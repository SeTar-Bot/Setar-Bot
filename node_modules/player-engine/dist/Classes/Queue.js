"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const PlayerTrack_1 = __importDefault(require("../Structers/PlayerTrack"));
const events_1 = require("events");
const Enums_1 = require("../utils/Enums");
const PlayerError_1 = __importDefault(require("../utils/PlayerError"));
class Queue extends events_1.EventEmitter {
    constructor(tracks) {
        super({
            captureRejections: true
        });
        this.initialized = false;
        this.tracks = [];
        this.endedTracks = [];
        this.isDestoryed = false;
        this.tracks = tracks ? tracks : [];
    }
    watchDestroyed(emit = true) {
        if (this.isDestoryed && emit)
            this.emit(Enums_1.QueueEvents.ERROR, new PlayerError_1.default(Enums_1.Errors.NOT_EXIST, `This Queue is destroyed and doesn't exist.`));
        return this.isDestoryed;
    }
    destroy() {
        if (this.watchDestroyed())
            return;
        this.tracks = [];
        this.endedTracks = [];
        this.currentTrack = null;
        this.isDestoryed = true;
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.watchDestroyed())
                return;
            this.currentTrack = this.tracks[0];
            try {
                for (const track of this.tracks)
                    yield track.init();
                for (const track of this.endedTracks)
                    yield track.init();
                this.currentTrack = this.tracks[0];
                this.initialized = true;
            }
            catch (e) {
                throw e;
            }
        });
    }
    setMusicBitrates(a) {
        if (this.watchDestroyed())
            return;
        this.tracks.map(x => { var _a, _b; return (_b = (_a = x.audioResource) === null || _a === void 0 ? void 0 : _a.encoder) === null || _b === void 0 ? void 0 : _b.setBitrate(a); });
        this.endedTracks.map(x => { var _a, _b; return (_b = (_a = x.audioResource) === null || _a === void 0 ? void 0 : _a.encoder) === null || _b === void 0 ? void 0 : _b.setBitrate(a); });
        this.currentTrack = this.tracks[0];
    }
    setMusicVolumes(a) {
        if (this.watchDestroyed())
            return;
        this.tracks.map(x => { var _a, _b; return (_b = (_a = x.audioResource) === null || _a === void 0 ? void 0 : _a.volume) === null || _b === void 0 ? void 0 : _b.setVolumeLogarithmic(a / 100); });
        this.endedTracks.map(x => { var _a, _b; return (_b = (_a = x.audioResource) === null || _a === void 0 ? void 0 : _a.volume) === null || _b === void 0 ? void 0 : _b.setVolumeLogarithmic(a / 100); });
        this.currentTrack = this.tracks[0];
    }
    clear() {
        if (this.watchDestroyed())
            return;
        this.tracks = [];
        this.endedTracks = [];
        this.currentTrack = null;
        this.emit(Enums_1.QueueEvents.CLEAN);
    }
    repeat() {
        if (this.watchDestroyed())
            return;
        this.endedTracks.unshift(this.currentTrack);
        this.tracks.concat(this.endedTracks);
        this.endedTracks = [];
        this.currentTrack = this.tracks[0];
    }
    repeatOne() {
        if (this.watchDestroyed())
            return;
        this.tracks.unshift(this.currentTrack);
    }
    nextTracks() {
        if (this.watchDestroyed())
            return;
        if (this.tracks.length) {
            const currentTrack = this.tracks.shift();
            const result = this.tracks;
            this.tracks.unshift(currentTrack);
            return result;
        }
        else
            return [];
    }
    previousTracks() {
        if (this.watchDestroyed())
            return;
        return this.endedTracks;
    }
    shuffle() {
        if (this.watchDestroyed())
            return;
        if (!this.tracks.length || this.tracks.length < 3)
            return false;
        const currentTrack = this.tracks.shift();
        for (let i = this.tracks.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [this.tracks[i], this.tracks[j]] = [this.tracks[j], this.tracks[i]];
        }
        this.tracks.unshift(currentTrack);
        return true;
    }
    current() {
        if (this.watchDestroyed())
            return;
        if (!this.currentTrack)
            this.currentTrack = this.tracks[0];
        console.log(`Returning: `, this.currentTrack);
        return this.currentTrack;
    }
    next() {
        if (this.watchDestroyed())
            return;
        if (this.tracks.length <= 1)
            return false;
        this.endedTracks.unshift(this.tracks.shift());
        this.currentTrack = this.tracks[0];
        return true;
    }
    back() {
        if (this.watchDestroyed())
            return;
        if (!this.endedTracks.length)
            return false;
        this.tracks.unshift(this.endedTracks.shift());
        this.currentTrack = this.tracks[0];
        return true;
    }
    skip(num = 1) {
        if (this.watchDestroyed())
            return;
        num = num - 1;
        if (num > this.tracks.length)
            return false;
        if (this.endedTracks.length > 0)
            this.endedTracks.concat(this.tracks.splice(0, num));
        else
            this.endedTracks = this.tracks.splice(0, num);
        this.currentTrack = this.tracks[0];
        this.emit(Enums_1.QueueEvents.CHANGE, { action: "skip", counts: num });
        return true;
    }
    previous(num = 1) {
        if (this.watchDestroyed())
            return;
        num = num - 1;
        if (num > this.endedTracks.length)
            return false;
        this.endedTracks.splice(0, num).concat(this.tracks);
        this.currentTrack = this.tracks[0];
        this.emit(Enums_1.QueueEvents.CHANGE, { action: "previous", counts: num });
        return true;
    }
    addTracks(x) {
        if (this.watchDestroyed())
            return;
        if (this.tracks.length > 0)
            this.tracks.concat(x);
        else
            this.tracks = x;
        this.currentTrack = this.tracks[0];
        return this;
    }
    remove(x, numbersToRemove) {
        if (this.watchDestroyed())
            return;
        if (x instanceof PlayerTrack_1.default) {
            const trackFound = this.tracks.find(s => s == x);
            if (!trackFound)
                return false;
            else {
                numbersToRemove = 1;
                const trackIndex = this.tracks.findIndex(s => s == x);
                const removed = this.tracks.splice(trackIndex, numbersToRemove);
                this.emit(Enums_1.QueueEvents.CHANGE, { action: "remove", counts: numbersToRemove, objects: removed });
                return true;
            }
        }
        else {
            if (!numbersToRemove)
                numbersToRemove = 1;
            const removed = this.tracks.splice(x, numbersToRemove);
            this.emit(Enums_1.QueueEvents.CHANGE, { action: "remove", counts: numbersToRemove, objects: removed });
            return true;
        }
    }
}
exports.default = Queue;
