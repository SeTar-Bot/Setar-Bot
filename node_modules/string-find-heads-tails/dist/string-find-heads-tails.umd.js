/**
 * @name string-find-heads-tails
 * @fileoverview Finds where are arbitrary templating marker heads and tails located
 * @version 5.0.12
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/string-find-heads-tails/}
 */

var stringFindHeadsTails=(()=>{var M=Object.defineProperty;var L=Object.getOwnPropertyDescriptor;var N=Object.getOwnPropertyNames,D=Object.getOwnPropertySymbols;var _=Object.prototype.hasOwnProperty,P=Object.prototype.propertyIsEnumerable;var S=(t,n,r)=>n in t?M(t,n,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[n]=r,I=(t,n)=>{for(var r in n||(n={}))_.call(n,r)&&S(t,r,n[r]);if(D)for(var r of D(n))P.call(n,r)&&S(t,r,n[r]);return t};var V=t=>M(t,"__esModule",{value:!0});var k=(t,n)=>{for(var r in n)M(t,r,{get:n[r],enumerable:!0})},J=(t,n,r,c)=>{if(n&&typeof n=="object"||typeof n=="function")for(let i of N(n))!_.call(t,i)&&(r||i!=="default")&&M(t,i,{get:()=>n[i],enumerable:!(c=L(n,i))||c.enumerable});return t};var q=(t=>(n,r)=>t&&t.get(n)||(r=J(V({}),n,1),t&&t.set(n,r),r))(typeof WeakMap!="undefined"?new WeakMap:0);var X={};k(X,{defaults:()=>R,strFindHeadsTails:()=>U,version:()=>K});function T(t){return typeof t=="string"?t.length?[t]:[]:t}function B(t){return t&&typeof t=="object"&&!Array.isArray(t)}function E(t){return typeof t=="string"}var H={cb:void 0,i:!1,trimBeforeMatching:!1,trimCharsBeforeMatching:[],maxMismatches:0,firstMustMatch:!1,lastMustMatch:!1,hungry:!1},v=t=>t+1;function F(t,n,r,c,i=!1,a=v){let h=typeof r=="function"?r():r;if(+n<0&&i&&h==="EOL")return h;let s=I(I({},H),c);if(n>=t.length&&!i)return!1;let g=i?1:r.length,$=0,u=!1,l=!1,d=!1,m=s.maxMismatches,e=n,o=!1,y=!1,f=!1;function p(){return $===1&&m<s.maxMismatches-1}for(;t[e];){let w=a(e);if(s.trimBeforeMatching&&t[e].trim()===""){if(!t[w]&&i&&r==="EOL")return!0;e=a(e);continue}if(s&&!s.i&&s.trimCharsBeforeMatching&&s.trimCharsBeforeMatching.includes(t[e])||(s==null?void 0:s.i)&&s.trimCharsBeforeMatching&&s.trimCharsBeforeMatching.map(A=>A.toLowerCase()).includes(t[e].toLowerCase())){if(i&&r==="EOL"&&!t[w])return!0;e=a(e);continue}let x=w>e?r[r.length-g]:r[g-1];if(!s.i&&t[e]===x||s.i&&t[e].toLowerCase()===x.toLowerCase()){if(o||(o=!0),d||(d=!0),g===r.length){if(y=!0,m!==s.maxMismatches)return!1}else g===1&&(f=!0);if(g-=1,$++,p())return!1;if(!g)return $!==r.length||m===s.maxMismatches||!u?e:!1}else if(!u&&!$&&(u=!0),s.maxMismatches&&m&&e){m-=1;for(let A=0;A<=m;A++){let O=w>e?r[r.length-g+1+A]:r[g-2-A],W=t[a(e)];if(O&&(!s.i&&t[e]===O||s.i&&t[e].toLowerCase()===O.toLowerCase())&&(!s.firstMustMatch||g!==r.length)){if($++,p())return!1;g-=2,o=!0;break}else if(W&&O&&(!s.i&&W===O||s.i&&W.toLowerCase()===O.toLowerCase())&&(!s.firstMustMatch||g!==r.length)){if(!$&&!s.hungry)return!1;g-=1,o=!0;break}else if(O===void 0&&m>=0&&o&&(!s.firstMustMatch||y)&&(!s.lastMustMatch||f))return e}o||(l=e)}else return e===0&&g===1&&!s.lastMustMatch&&d?0:!1;if(l!==!1&&l!==e&&(l=!1),g<1)return e;e=a(e)}if(g>0)return i&&h==="EOL"?!0:s&&s.maxMismatches>=g&&d?l||0:!1}function z(t,n,r,c,i){if(B(i)&&Object.prototype.hasOwnProperty.call(i,"trimBeforeMatching")&&typeof i.trimBeforeMatching!="boolean")throw new Error(`string-match-left-right/${t}(): [THROW_ID_09] opts.trimBeforeMatching should be boolean!${Array.isArray(i.trimBeforeMatching)?" Did you mean to use opts.trimCharsBeforeMatching?":""}`);let a=I(I({},H),i);if(typeof a.trimCharsBeforeMatching=="string"&&(a.trimCharsBeforeMatching=T(a.trimCharsBeforeMatching)),a.trimCharsBeforeMatching=a.trimCharsBeforeMatching.map(u=>E(u)?u:String(u)),!E(n)||!n.length)return!1;if(!Number.isInteger(r)||r<0)throw new Error(`string-match-left-right/${t}(): [THROW_ID_03] the second argument should be a natural number. Currently it's of a type: ${typeof r}, equal to:
${JSON.stringify(r,null,4)}`);let h,s;if(E(c))h=[c];else if(Array.isArray(c))h=c;else if(!c)h=c;else if(typeof c=="function")h=[],h.push(c);else throw new Error(`string-match-left-right/${t}(): [THROW_ID_05] the third argument, whatToMatch, is neither string nor array of strings! It's ${typeof c}, equal to:
${JSON.stringify(c,null,4)}`);if(i&&!B(i))throw new Error(`string-match-left-right/${t}(): [THROW_ID_06] the fourth argument, options object, should be a plain object. Currently it's of a type "${typeof i}", and equal to:
${JSON.stringify(i,null,4)}`);let g=0,$="";if((a==null?void 0:a.trimCharsBeforeMatching)&&a.trimCharsBeforeMatching.some((u,l)=>u.length>1?(g=l,$=u,!0):!1))throw new Error(`string-match-left-right/${t}(): [THROW_ID_07] the fourth argument, options object contains trimCharsBeforeMatching. It was meant to list the single characters but one of the entries at index ${g} is longer than 1 character, ${$.length} (equals to ${$}). Please split it into separate characters and put into array as separate elements.`);if(!h||!Array.isArray(h)||Array.isArray(h)&&!h.length||Array.isArray(h)&&h.length===1&&E(h[0])&&!h[0].trim()){if(typeof a.cb=="function"){let l,d=r;if((t==="matchLeftIncl"||t==="matchRight")&&(d+=1),t[5]==="L")for(let y=d;y--;){let f=n[y];if((!a.trimBeforeMatching||a.trimBeforeMatching&&f!==void 0&&f.trim())&&(!a.trimCharsBeforeMatching||!a.trimCharsBeforeMatching.length||f!==void 0&&!a.trimCharsBeforeMatching.includes(f))){l=y;break}}else if(t.startsWith("matchRight"))for(let y=d;y<n.length;y++){let f=n[y];if((!a.trimBeforeMatching||a.trimBeforeMatching&&f.trim())&&(!a.trimCharsBeforeMatching||!a.trimCharsBeforeMatching.length||!a.trimCharsBeforeMatching.includes(f))){l=y;break}}if(l===void 0)return!1;let m=n[l],e=l+1,o="";return e&&e>0&&(o=n.slice(0,e)),t[5]==="L"||l&&l>0&&(o=n.slice(l)),a.cb(m,o,l)}let u="";throw i||(u=" More so, the whole options object, the fourth input argument, is missing!"),new Error(`string-match-left-right/${t}(): [THROW_ID_08] the third argument, "whatToMatch", was given as an empty string. This means, you intend to match purely by a callback. The callback was not set though, the opts key "cb" is not set!${u}`)}for(let u=0,l=h.length;u<l;u++){s=typeof h[u]=="function";let d=h[u],m,e,o="",y=r;t==="matchRight"?y+=1:t==="matchLeft"&&(y-=1);let f=F(n,y,d,a,s,p=>t[5]==="L"?p-1:p+1);if(f&&s&&typeof d=="function"&&d()==="EOL")return d()&&(a.cb?a.cb(m,o,e):!0)?d():!1;if(Number.isInteger(f)&&(e=t.startsWith("matchLeft")?f-1:f+1,t[5]==="L"?o=n.slice(0,f):o=n.slice(e)),e<0&&(e=void 0),n[e]&&(m=n[e]),Number.isInteger(f)&&(a.cb?a.cb(m,o,e):!0))return d}return!1}function C(t,n,r,c){return z("matchRightIncl",t,n,r,c)}var j="5.0.12";var K=j;function Q(t){return t&&typeof t=="object"&&!Array.isArray(t)}function b(t){return typeof t=="string"}var R={fromIndex:0,throwWhenSomethingWrongIsDetected:!0,allowWholeValueToBeOnlyHeadsOrTails:!0,source:"string-find-heads-tails",matchHeadsAndTailsStrictlyInPairsByTheirOrder:!1,relaxedAPI:!1};function U(t,n,r,c){if(c&&!Q(c))throw new TypeError(`string-find-heads-tails: [THROW_ID_01] the fourth input argument, an Optional Options Object, must be a plain object! Currently it's equal to: ${c} (type: ${typeof c})`);let i=I(I({},R),c);if(typeof i.fromIndex=="string"&&/^\d*$/.test(i.fromIndex))i.fromIndex=Number(i.fromIndex);else if(!Number.isInteger(i.fromIndex)||i.fromIndex<0)throw new TypeError(`${i.source} [THROW_ID_18] the fourth input argument must be a natural number or zero! Currently it's: ${i.fromIndex}`);if(!b(t)||t.length===0){if(i.relaxedAPI)return[];throw new TypeError(`string-find-heads-tails: [THROW_ID_02] the first input argument, input string, must be a non-zero-length string! Currently it's: ${typeof t}, equal to: ${t}`)}let a,h;if(typeof n!="string"&&!Array.isArray(n)){if(i.relaxedAPI)return[];throw new TypeError(`string-find-heads-tails: [THROW_ID_03] the second input argument, heads, must be either a string or an array of strings! Currently it's: ${typeof n}, equal to:
${JSON.stringify(n,null,4)}`)}else if(typeof n=="string")if(n.length===0){if(i.relaxedAPI)return[];throw new TypeError("string-find-heads-tails: [THROW_ID_04] the second input argument, heads, must be a non-empty string! Currently it's empty.")}else n=T(n);else if(Array.isArray(n))if(n.length===0){if(i.relaxedAPI)return[];throw new TypeError("string-find-heads-tails: [THROW_ID_05] the second input argument, heads, must be a non-empty array and contain at least one string! Currently it's empty.")}else if(n.every((e,o)=>(a=e,h=o,b(e)))){if(!n.every((e,o)=>(h=o,b(e)&&e.length>0&&e.trim()!=="")))if(i.relaxedAPI){if(n=n.filter(e=>b(e)&&e.length>0),n.length===0)return[]}else throw new TypeError(`string-find-heads-tails: [THROW_ID_07] the second input argument, heads, should not contain empty strings! For example, there's one detected at index ${h} of heads array:
${JSON.stringify(n,null,4)}.`)}else if(i.relaxedAPI){if(n=n.filter(e=>b(e)&&e.length>0),n.length===0)return[]}else throw new TypeError(`string-find-heads-tails: [THROW_ID_06] the second input argument, heads, contains non-string elements! For example, element at ${h}th index is ${typeof a}, equal to:
${JSON.stringify(a,null,4)}. Whole heads array looks like:
${JSON.stringify(n,null,4)}`);if(!b(r)&&!Array.isArray(r)){if(i.relaxedAPI)return[];throw new TypeError(`string-find-heads-tails: [THROW_ID_08] the third input argument, tails, must be either a string or an array of strings! Currently it's: ${typeof r}, equal to:
${JSON.stringify(r,null,4)}`)}else if(b(r))if(r.length===0){if(i.relaxedAPI)return[];throw new TypeError("string-find-heads-tails: [THROW_ID_09] the third input argument, tails, must be a non-empty string! Currently it's empty.")}else r=T(r);else if(Array.isArray(r))if(r.length===0){if(i.relaxedAPI)return[];throw new TypeError("string-find-heads-tails: [THROW_ID_10] the third input argument, tails, must be a non-empty array and contain at least one string! Currently it's empty.")}else if(r.every((e,o)=>(a=e,h=o,b(e)))){if(!r.every((e,o)=>(h=o,b(e)&&e.length>0&&e.trim()!=="")))if(i.relaxedAPI){if(r=r.filter(e=>b(e)&&e.length>0),r.length===0)return[]}else throw new TypeError(`string-find-heads-tails: [THROW_ID_12] the third input argument, tails, should not contain empty strings! For example, there's one detected at index ${h}. Whole tails array is equal to:
${JSON.stringify(r,null,4)}`)}else if(i.relaxedAPI){if(r=r.filter(e=>b(e)&&e.length>0),r.length===0)return[]}else throw new TypeError(`string-find-heads-tails: [THROW_ID_11] the third input argument, tails, contains non-string elements! For example, element at ${h}th index is ${typeof a}, equal to:
${JSON.stringify(a,null,4)}. Whole tails array is equal to:
${JSON.stringify(r,null,4)}`);let s=i.source===R.source;if(i.throwWhenSomethingWrongIsDetected&&!i.allowWholeValueToBeOnlyHeadsOrTails){if(T(n).includes(t))throw new Error(`${i.source}${s?": [THROW_ID_16]":""} the whole input string can't be equal to ${b(n)?"":"one of "}heads (${t})!`);if(T(r).includes(t))throw new Error(`${i.source}${s?": [THROW_ID_17]":""} the whole input string can't be equal to ${b(r)?"":"one of "}tails (${t})!`)}let g=n.concat(r).map(e=>e.charAt(0)).reduce((e,o)=>o.charCodeAt(0)>e[1]?[e[0],o.charCodeAt(0)]:o.charCodeAt(0)<e[0]?[o.charCodeAt(0),e[1]]:e,[n[0].charCodeAt(0),n[0].charCodeAt(0)]),$=[],u=!1,l={},d="",m;for(let e=i.fromIndex,o=t.length;e<o;e++){let y=t[e].charCodeAt(0);if(y<=g[1]&&y>=g[0]){let f=C(t,e,n);if(f&&i.matchHeadsAndTailsStrictlyInPairsByTheirOrder){for(let w=n.length;w--;)if(n[w]===f){m=w;break}}if(typeof f=="string")if(u){if(i.throwWhenSomethingWrongIsDetected)throw new TypeError(`${i.source}${s?": [THROW_ID_19]":""} When processing "${t}", we found heads (${t.slice(e,e+f.length)}) starting at character with index number "${e}" and there was another set of heads before it! Generally speaking, there should be "heads-tails-heads-tails", not "heads-heads-tails"!
We're talking about the area of the code:


--------------------------------------starts
${t.slice(Math.max(e-200,0),e)}
      ${`\x1B[${33}m------->\x1B[${39}m`} ${`\x1B[${31}m${t.slice(e,e+f.length)}\x1B[${39}m`} \x1B[${33}m<-------\x1B[${39}m
${t.slice(e+f.length,Math.min(o,e+200))}
--------------------------------------ends


To turn off this error being thrown, set opts.throwWhenSomethingWrongIsDetected to Boolean false.`)}else{l={},l.headsStartAt=e,l.headsEndAt=e+f.length,u=!0,e+=f.length-1,d&&(d="");continue}let p=C(t,e,r);if(u&&p&&i.matchHeadsAndTailsStrictlyInPairsByTheirOrder&&m!==void 0&&r[m]!==void 0&&r[m]!==p){let w;for(let x=r.length;x--;)if(r[x]===p){w=x;break}throw new TypeError(`${i.source}${s?": [THROW_ID_20]":""} When processing "${t}", we had "opts.matchHeadsAndTailsStrictlyInPairsByTheirOrder" on. We found heads (${n[m]}) but the tails the followed it were not of the same index, ${m} (${r[m]}) but ${w} (${p}).`)}if(typeof p=="string")if(u){l.tailsStartAt=e,l.tailsEndAt=e+p.length,$.push(l),l={},u=!1,e+=p.length-1;continue}else i.throwWhenSomethingWrongIsDetected&&(d=`${i.source}${s?": [THROW_ID_21]":""} When processing "${t}", we found tails (${t.slice(e,e+p.length)}) starting at character with index number "${e}" but there were no heads preceding it. That's very naughty!`)}if(i.throwWhenSomethingWrongIsDetected&&e===o-1){if(Object.keys(l).length!==0)throw new TypeError(`${i.source}${s?": [THROW_ID_22]":""} When processing "${t}", we reached the end of the string and yet didn't find any tails (${JSON.stringify(r,null,4)}) to match the last detected heads (${t.slice(l.headsStartAt,l.headsEndAt)})!`);if(d)throw new Error(d)}}return $}return q(X);})();
/**
 * @name arrayiffy-if-string
 * @fileoverview Put non-empty strings into arrays, turn empty-ones into empty arrays. Bypass everything else.
 * @version 4.0.12
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/arrayiffy-if-string/}
 */
/**
 * @name string-match-left-right
 * @fileoverview Match substrings on the left or right of a given index, ignoring whitespace
 * @version 8.0.12
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/string-match-left-right/}
 */
