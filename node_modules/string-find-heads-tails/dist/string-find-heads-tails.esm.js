/**
 * @name string-find-heads-tails
 * @fileoverview Finds where are arbitrary templating marker heads and tails located
 * @version 5.0.12
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/string-find-heads-tails/}
 */

import{matchRightIncl as x}from"string-match-left-right";import{arrayiffy as $}from"arrayiffy-if-string";var O="5.0.12";var H=O;function D(i){return i&&typeof i=="object"&&!Array.isArray(i)}function o(i){return typeof i=="string"}var A={fromIndex:0,throwWhenSomethingWrongIsDetected:!0,allowWholeValueToBeOnlyHeadsOrTails:!0,source:"string-find-heads-tails",matchHeadsAndTailsStrictlyInPairsByTheirOrder:!1,relaxedAPI:!1};function j(i,n,r,y){if(y&&!D(y))throw new TypeError(`string-find-heads-tails: [THROW_ID_01] the fourth input argument, an Optional Options Object, must be a plain object! Currently it's equal to: ${y} (type: ${typeof y})`);let t={...A,...y};if(typeof t.fromIndex=="string"&&/^\d*$/.test(t.fromIndex))t.fromIndex=Number(t.fromIndex);else if(!Number.isInteger(t.fromIndex)||t.fromIndex<0)throw new TypeError(`${t.source} [THROW_ID_18] the fourth input argument must be a natural number or zero! Currently it's: ${t.fromIndex}`);if(!o(i)||i.length===0){if(t.relaxedAPI)return[];throw new TypeError(`string-find-heads-tails: [THROW_ID_02] the first input argument, input string, must be a non-zero-length string! Currently it's: ${typeof i}, equal to: ${i}`)}let f,l;if(typeof n!="string"&&!Array.isArray(n)){if(t.relaxedAPI)return[];throw new TypeError(`string-find-heads-tails: [THROW_ID_03] the second input argument, heads, must be either a string or an array of strings! Currently it's: ${typeof n}, equal to:
${JSON.stringify(n,null,4)}`)}else if(typeof n=="string")if(n.length===0){if(t.relaxedAPI)return[];throw new TypeError("string-find-heads-tails: [THROW_ID_04] the second input argument, heads, must be a non-empty string! Currently it's empty.")}else n=$(n);else if(Array.isArray(n))if(n.length===0){if(t.relaxedAPI)return[];throw new TypeError("string-find-heads-tails: [THROW_ID_05] the second input argument, heads, must be a non-empty array and contain at least one string! Currently it's empty.")}else if(n.every((e,s)=>(f=e,l=s,o(e)))){if(!n.every((e,s)=>(l=s,o(e)&&e.length>0&&e.trim()!=="")))if(t.relaxedAPI){if(n=n.filter(e=>o(e)&&e.length>0),n.length===0)return[]}else throw new TypeError(`string-find-heads-tails: [THROW_ID_07] the second input argument, heads, should not contain empty strings! For example, there's one detected at index ${l} of heads array:
${JSON.stringify(n,null,4)}.`)}else if(t.relaxedAPI){if(n=n.filter(e=>o(e)&&e.length>0),n.length===0)return[]}else throw new TypeError(`string-find-heads-tails: [THROW_ID_06] the second input argument, heads, contains non-string elements! For example, element at ${l}th index is ${typeof f}, equal to:
${JSON.stringify(f,null,4)}. Whole heads array looks like:
${JSON.stringify(n,null,4)}`);if(!o(r)&&!Array.isArray(r)){if(t.relaxedAPI)return[];throw new TypeError(`string-find-heads-tails: [THROW_ID_08] the third input argument, tails, must be either a string or an array of strings! Currently it's: ${typeof r}, equal to:
${JSON.stringify(r,null,4)}`)}else if(o(r))if(r.length===0){if(t.relaxedAPI)return[];throw new TypeError("string-find-heads-tails: [THROW_ID_09] the third input argument, tails, must be a non-empty string! Currently it's empty.")}else r=$(r);else if(Array.isArray(r))if(r.length===0){if(t.relaxedAPI)return[];throw new TypeError("string-find-heads-tails: [THROW_ID_10] the third input argument, tails, must be a non-empty array and contain at least one string! Currently it's empty.")}else if(r.every((e,s)=>(f=e,l=s,o(e)))){if(!r.every((e,s)=>(l=s,o(e)&&e.length>0&&e.trim()!=="")))if(t.relaxedAPI){if(r=r.filter(e=>o(e)&&e.length>0),r.length===0)return[]}else throw new TypeError(`string-find-heads-tails: [THROW_ID_12] the third input argument, tails, should not contain empty strings! For example, there's one detected at index ${l}. Whole tails array is equal to:
${JSON.stringify(r,null,4)}`)}else if(t.relaxedAPI){if(r=r.filter(e=>o(e)&&e.length>0),r.length===0)return[]}else throw new TypeError(`string-find-heads-tails: [THROW_ID_11] the third input argument, tails, contains non-string elements! For example, element at ${l}th index is ${typeof f}, equal to:
${JSON.stringify(f,null,4)}. Whole tails array is equal to:
${JSON.stringify(r,null,4)}`);let c=t.source===A.source;if(t.throwWhenSomethingWrongIsDetected&&!t.allowWholeValueToBeOnlyHeadsOrTails){if($(n).includes(i))throw new Error(`${t.source}${c?": [THROW_ID_16]":""} the whole input string can't be equal to ${o(n)?"":"one of "}heads (${i})!`);if($(r).includes(i))throw new Error(`${t.source}${c?": [THROW_ID_17]":""} the whole input string can't be equal to ${o(r)?"":"one of "}tails (${i})!`)}let w=n.concat(r).map(e=>e.charAt(0)).reduce((e,s)=>s.charCodeAt(0)>e[1]?[e[0],s.charCodeAt(0)]:s.charCodeAt(0)<e[0]?[s.charCodeAt(0),e[1]]:e,[n[0].charCodeAt(0),n[0].charCodeAt(0)]),I=[],p=!1,a={},m="",u;for(let e=t.fromIndex,s=i.length;e<s;e++){let T=i[e].charCodeAt(0);if(T<=w[1]&&T>=w[0]){let d=x(i,e,n);if(d&&t.matchHeadsAndTailsStrictlyInPairsByTheirOrder){for(let g=n.length;g--;)if(n[g]===d){u=g;break}}if(typeof d=="string")if(p){if(t.throwWhenSomethingWrongIsDetected)throw new TypeError(`${t.source}${c?": [THROW_ID_19]":""} When processing "${i}", we found heads (${i.slice(e,e+d.length)}) starting at character with index number "${e}" and there was another set of heads before it! Generally speaking, there should be "heads-tails-heads-tails", not "heads-heads-tails"!
We're talking about the area of the code:


--------------------------------------starts
${i.slice(Math.max(e-200,0),e)}
      ${`\x1B[${33}m------->\x1B[${39}m`} ${`\x1B[${31}m${i.slice(e,e+d.length)}\x1B[${39}m`} \x1B[${33}m<-------\x1B[${39}m
${i.slice(e+d.length,Math.min(s,e+200))}
--------------------------------------ends


To turn off this error being thrown, set opts.throwWhenSomethingWrongIsDetected to Boolean false.`)}else{a={},a.headsStartAt=e,a.headsEndAt=e+d.length,p=!0,e+=d.length-1,m&&(m="");continue}let h=x(i,e,r);if(p&&h&&t.matchHeadsAndTailsStrictlyInPairsByTheirOrder&&u!==void 0&&r[u]!==void 0&&r[u]!==h){let g;for(let b=r.length;b--;)if(r[b]===h){g=b;break}throw new TypeError(`${t.source}${c?": [THROW_ID_20]":""} When processing "${i}", we had "opts.matchHeadsAndTailsStrictlyInPairsByTheirOrder" on. We found heads (${n[u]}) but the tails the followed it were not of the same index, ${u} (${r[u]}) but ${g} (${h}).`)}if(typeof h=="string")if(p){a.tailsStartAt=e,a.tailsEndAt=e+h.length,I.push(a),a={},p=!1,e+=h.length-1;continue}else t.throwWhenSomethingWrongIsDetected&&(m=`${t.source}${c?": [THROW_ID_21]":""} When processing "${i}", we found tails (${i.slice(e,e+h.length)}) starting at character with index number "${e}" but there were no heads preceding it. That's very naughty!`)}if(t.throwWhenSomethingWrongIsDetected&&e===s-1){if(Object.keys(a).length!==0)throw new TypeError(`${t.source}${c?": [THROW_ID_22]":""} When processing "${i}", we reached the end of the string and yet didn't find any tails (${JSON.stringify(r,null,4)}) to match the last detected heads (${i.slice(a.headsStartAt,a.headsEndAt)})!`);if(m)throw new Error(m)}}return I}export{A as defaults,j as strFindHeadsTails,H as version};
