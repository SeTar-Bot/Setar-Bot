/**
 * @name string-remove-duplicate-heads-tails
 * @fileoverview Detect and (recursively) remove head and tail wrappings around the input string
 * @version 6.0.12
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/string-remove-duplicate-heads-tails/}
 */

var stringRemoveDuplicateHeadsTails=(()=>{var ae=Object.create;var A=Object.defineProperty;var le=Object.getOwnPropertyDescriptor;var ue=Object.getOwnPropertyNames,x=Object.getOwnPropertySymbols,ge=Object.getPrototypeOf,j=Object.prototype.hasOwnProperty,he=Object.prototype.propertyIsEnumerable;var C=(e,n,i)=>n in e?A(e,n,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[n]=i,d=(e,n)=>{for(var i in n||(n={}))j.call(n,i)&&C(e,i,n[i]);if(x)for(var i of x(n))he.call(n,i)&&C(e,i,n[i]);return e};var B=e=>A(e,"__esModule",{value:!0});var ce=(e,n)=>()=>(n||e((n={exports:{}}).exports,n),n.exports),fe=(e,n)=>{for(var i in n)A(e,i,{get:n[i],enumerable:!0})},L=(e,n,i,s)=>{if(n&&typeof n=="object"||typeof n=="function")for(let u of ue(n))!j.call(e,u)&&(i||u!=="default")&&A(e,u,{get:()=>n[u],enumerable:!(s=le(n,u))||s.enumerable});return e},me=(e,n)=>L(B(A(e!=null?ae(ge(e)):{},"default",!n&&e&&e.__esModule?{get:()=>e.default,enumerable:!0}:{value:e,enumerable:!0})),e),pe=(e=>(n,i)=>e&&e.get(n)||(i=L(B({}),n,1),e&&e.set(n,i),i))(typeof WeakMap!="undefined"?new WeakMap:0);var J=(e,n,i)=>(C(e,typeof n!="symbol"?n+"":n,i),i);var G=ce((We,z)=>{var ye="[object Object]";function de(e){var n=!1;if(e!=null&&typeof e.toString!="function")try{n=!!(e+"")}catch(i){}return n}function $e(e,n){return function(i){return e(n(i))}}var be=Function.prototype,q=Object.prototype,P=be.toString,Te=q.hasOwnProperty,we=P.call(Object),Oe=q.toString,Ee=$e(Object.getPrototypeOf,Object);function Me(e){return!!e&&typeof e=="object"}function De(e){if(!Me(e)||Oe.call(e)!=ye||de(e))return!1;var n=Ee(e);if(n===null)return!0;var i=Te.call(n,"constructor")&&n.constructor;return typeof i=="function"&&i instanceof i&&P.call(i)==we}z.exports=De});var Ve={};fe(Ve,{defaults:()=>ie,remDup:()=>Je,version:()=>Ce});var se=me(G(),1);function N(e){return typeof e=="string"?e.length?[e]:[]:e}function U(e){return e&&typeof e=="object"&&!Array.isArray(e)}function _(e){return typeof e=="string"}var K={cb:void 0,i:!1,trimBeforeMatching:!1,trimCharsBeforeMatching:[],maxMismatches:0,firstMustMatch:!1,lastMustMatch:!1,hungry:!1},Ne=e=>e+1;function Ie(e,n,i,s,u=!1,t=Ne){let a=typeof i=="function"?i():i;if(+n<0&&u&&a==="EOL")return a;let o=d(d({},K),s);if(n>=e.length&&!u)return!1;let l=u?1:i.length,r=0,g=!1,f=!1,y=!1,m=o.maxMismatches,c=n,h=!1,$=!1,p=!1;function O(){return r===1&&m<o.maxMismatches-1}for(;e[c];){let D=t(c);if(o.trimBeforeMatching&&e[c].trim()===""){if(!e[D]&&u&&i==="EOL")return!0;c=t(c);continue}if(o&&!o.i&&o.trimCharsBeforeMatching&&o.trimCharsBeforeMatching.includes(e[c])||(o==null?void 0:o.i)&&o.trimCharsBeforeMatching&&o.trimCharsBeforeMatching.map(T=>T.toLowerCase()).includes(e[c].toLowerCase())){if(u&&i==="EOL"&&!e[D])return!0;c=t(c);continue}let w=D>c?i[i.length-l]:i[l-1];if(!o.i&&e[c]===w||o.i&&e[c].toLowerCase()===w.toLowerCase()){if(h||(h=!0),y||(y=!0),l===i.length){if($=!0,m!==o.maxMismatches)return!1}else l===1&&(p=!0);if(l-=1,r++,O())return!1;if(!l)return r!==i.length||m===o.maxMismatches||!g?c:!1}else if(!g&&!r&&(g=!0),o.maxMismatches&&m&&c){m-=1;for(let T=0;T<=m;T++){let b=D>c?i[i.length-l+1+T]:i[l-2-T],S=e[t(c)];if(b&&(!o.i&&e[c]===b||o.i&&e[c].toLowerCase()===b.toLowerCase())&&(!o.firstMustMatch||l!==i.length)){if(r++,O())return!1;l-=2,h=!0;break}else if(S&&b&&(!o.i&&S===b||o.i&&S.toLowerCase()===b.toLowerCase())&&(!o.firstMustMatch||l!==i.length)){if(!r&&!o.hungry)return!1;l-=1,h=!0;break}else if(b===void 0&&m>=0&&h&&(!o.firstMustMatch||$)&&(!o.lastMustMatch||p))return c}h||(f=c)}else return c===0&&l===1&&!o.lastMustMatch&&y?0:!1;if(f!==!1&&f!==c&&(f=!1),l<1)return c;c=t(c)}if(l>0)return u&&a==="EOL"?!0:o&&o.maxMismatches>=l&&y?f||0:!1}function Q(e,n,i,s,u){if(U(u)&&Object.prototype.hasOwnProperty.call(u,"trimBeforeMatching")&&typeof u.trimBeforeMatching!="boolean")throw new Error(`string-match-left-right/${e}(): [THROW_ID_09] opts.trimBeforeMatching should be boolean!${Array.isArray(u.trimBeforeMatching)?" Did you mean to use opts.trimCharsBeforeMatching?":""}`);let t=d(d({},K),u);if(typeof t.trimCharsBeforeMatching=="string"&&(t.trimCharsBeforeMatching=N(t.trimCharsBeforeMatching)),t.trimCharsBeforeMatching=t.trimCharsBeforeMatching.map(g=>_(g)?g:String(g)),!_(n)||!n.length)return!1;if(!Number.isInteger(i)||i<0)throw new Error(`string-match-left-right/${e}(): [THROW_ID_03] the second argument should be a natural number. Currently it's of a type: ${typeof i}, equal to:
${JSON.stringify(i,null,4)}`);let a,o;if(_(s))a=[s];else if(Array.isArray(s))a=s;else if(!s)a=s;else if(typeof s=="function")a=[],a.push(s);else throw new Error(`string-match-left-right/${e}(): [THROW_ID_05] the third argument, whatToMatch, is neither string nor array of strings! It's ${typeof s}, equal to:
${JSON.stringify(s,null,4)}`);if(u&&!U(u))throw new Error(`string-match-left-right/${e}(): [THROW_ID_06] the fourth argument, options object, should be a plain object. Currently it's of a type "${typeof u}", and equal to:
${JSON.stringify(u,null,4)}`);let l=0,r="";if((t==null?void 0:t.trimCharsBeforeMatching)&&t.trimCharsBeforeMatching.some((g,f)=>g.length>1?(l=f,r=g,!0):!1))throw new Error(`string-match-left-right/${e}(): [THROW_ID_07] the fourth argument, options object contains trimCharsBeforeMatching. It was meant to list the single characters but one of the entries at index ${l} is longer than 1 character, ${r.length} (equals to ${r}). Please split it into separate characters and put into array as separate elements.`);if(!a||!Array.isArray(a)||Array.isArray(a)&&!a.length||Array.isArray(a)&&a.length===1&&_(a[0])&&!a[0].trim()){if(typeof t.cb=="function"){let f,y=i;if((e==="matchLeftIncl"||e==="matchRight")&&(y+=1),e[5]==="L")for(let $=y;$--;){let p=n[$];if((!t.trimBeforeMatching||t.trimBeforeMatching&&p!==void 0&&p.trim())&&(!t.trimCharsBeforeMatching||!t.trimCharsBeforeMatching.length||p!==void 0&&!t.trimCharsBeforeMatching.includes(p))){f=$;break}}else if(e.startsWith("matchRight"))for(let $=y;$<n.length;$++){let p=n[$];if((!t.trimBeforeMatching||t.trimBeforeMatching&&p.trim())&&(!t.trimCharsBeforeMatching||!t.trimCharsBeforeMatching.length||!t.trimCharsBeforeMatching.includes(p))){f=$;break}}if(f===void 0)return!1;let m=n[f],c=f+1,h="";return c&&c>0&&(h=n.slice(0,c)),e[5]==="L"||f&&f>0&&(h=n.slice(f)),t.cb(m,h,f)}let g="";throw u||(g=" More so, the whole options object, the fourth input argument, is missing!"),new Error(`string-match-left-right/${e}(): [THROW_ID_08] the third argument, "whatToMatch", was given as an empty string. This means, you intend to match purely by a callback. The callback was not set though, the opts key "cb" is not set!${g}`)}for(let g=0,f=a.length;g<f;g++){o=typeof a[g]=="function";let y=a[g],m,c,h="",$=i;e==="matchRight"?$+=1:e==="matchLeft"&&($-=1);let p=Ie(n,$,y,t,o,O=>e[5]==="L"?O-1:O+1);if(p&&o&&typeof y=="function"&&y()==="EOL")return y()&&(t.cb?t.cb(m,h,c):!0)?y():!1;if(Number.isInteger(p)&&(c=e.startsWith("matchLeft")?p-1:p+1,e[5]==="L"?h=n.slice(0,p):h=n.slice(c)),c<0&&(c=void 0),n[c]&&(m=n[c]),Number.isInteger(p)&&(t.cb?t.cb(m,h,c):!0))return y}return!1}function F(e,n,i,s){return Q("matchLeftIncl",e,n,i,s)}function I(e,n,i,s){return Q("matchRightIncl",e,n,i,s)}function k(e,n=1){let i="\xA0";function s(t){return Array.from(t).reverse().join("")}function u(t,a,o){let l=o?`
`:"\r",r=o?"\r":`
`;if(!t)return t;let g=0,f=0,y="";for(let m=0,c=t.length;m<c;m++)(t[m]===l||t[m]===r&&t[m-1]!==l)&&f++,`\r
`.includes(t[m])||t[m]===i?(g=0,t[m]===i?y+=t[m]:t[m]===l?f<=a&&(y+=t[m],t[m+1]===r&&(y+=t[m+1],m++)):t[m]===r&&(!t[m-1]||t[m-1]!==l)&&f<=a&&(y+=t[m])):(g++,!t[m+1]&&!f&&(y+=" "));return y}if(typeof e=="string"&&e.length){let t=1;typeof+n=="number"&&Number.isInteger(+n)&&+n>=0&&(t=+n);let a="",o="";if(!e.trim())a=e;else if(!e[0].trim()){for(let l=0,r=e.length;l<r;l++)if(e[l].trim()){a=e.slice(0,l);break}}if(e.trim()&&(e.slice(-1).trim()===""||e.slice(-1)===i)){for(let l=e.length;l--;)if(e[l].trim()){o=e.slice(l+1);break}}return`${u(a,t,!1)}${e.trim()}${s(u(s(o),t,!0))}`}return e}var Ae={strictlyTwoElementsInRangeArrays:!1,progressFn:null};function X(e,n){if(!Array.isArray(e)||!e.length)return e;let i=d(d({},Ae),n),s,u;if(i.strictlyTwoElementsInRangeArrays&&!e.every((o,l)=>!Array.isArray(o)||o.length!==2?(s=l,u=o.length,!1):!0))throw new TypeError(`ranges-sort: [THROW_ID_03] The first argument should be an array and must consist of arrays which are natural number indexes representing TWO string index ranges. However, ${s}th range (${JSON.stringify(e[s],null,4)}) has not two but ${u} elements!`);if(!e.every((o,l)=>!Array.isArray(o)||!Number.isInteger(o[0])||o[0]<0||!Number.isInteger(o[1])||o[1]<0?(s=l,!1):!0))throw new TypeError(`ranges-sort: [THROW_ID_04] The first argument should be an array and must consist of arrays which are natural number indexes representing string index ranges. However, ${s}th range (${JSON.stringify(e[s],null,4)}) does not consist of only natural numbers!`);let t=e.length**2,a=0;return Array.from(e).sort((o,l)=>(i.progressFn&&(a+=1,i.progressFn(Math.floor(a*100/t))),o[0]===l[0]?o[1]<l[1]?-1:o[1]>l[1]?1:0:o[0]<l[0]?-1:1))}var Y={mergeType:1,progressFn:null,joinRangesThatTouchEdges:!0};function Re(e,n){function i(r){return r&&typeof r=="object"&&!Array.isArray(r)}if(!Array.isArray(e)||!e.length)return null;let s;if(n)if(i(n)){if(s=d(d({},Y),n),s.progressFn&&i(s.progressFn)&&!Object.keys(s.progressFn).length)s.progressFn=null;else if(s.progressFn&&typeof s.progressFn!="function")throw new Error(`ranges-merge: [THROW_ID_01] opts.progressFn must be a function! It was given of a type: "${typeof s.progressFn}", equal to ${JSON.stringify(s.progressFn,null,4)}`);if(![1,2,"1","2"].includes(s.mergeType))throw new Error(`ranges-merge: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "${typeof s.mergeType}", equal to ${JSON.stringify(s.mergeType,null,4)}`);if(typeof s.joinRangesThatTouchEdges!="boolean")throw new Error(`ranges-merge: [THROW_ID_04] opts.joinRangesThatTouchEdges was customised to a wrong thing! It was given of a type: "${typeof s.joinRangesThatTouchEdges}", equal to ${JSON.stringify(s.joinRangesThatTouchEdges,null,4)}`)}else throw new Error(`emlint: [THROW_ID_03] the second input argument must be a plain object. It was given as:
${JSON.stringify(n,null,4)} (type ${typeof n})`);else s=d({},Y);let u=e.filter(r=>Array.isArray(r)).map(r=>[...r]).filter(r=>r[2]!==void 0||r[0]!==r[1]),t,a,o;s.progressFn?t=X(u,{progressFn:r=>{o=Math.floor(r/5),o!==a&&(a=o,s.progressFn(o))}}):t=X(u);let l=t.length-1;for(let r=l;r>0;r--)s.progressFn&&(o=Math.floor((1-r/l)*78)+21,o!==a&&o>a&&(a=o,s.progressFn(o))),(t[r][0]<=t[r-1][0]||!s.joinRangesThatTouchEdges&&t[r][0]<t[r-1][1]||s.joinRangesThatTouchEdges&&t[r][0]<=t[r-1][1])&&(t[r-1][0]=Math.min(t[r][0],t[r-1][0]),t[r-1][1]=Math.max(t[r][1],t[r-1][1]),t[r][2]!==void 0&&(t[r-1][0]>=t[r][0]||t[r-1][1]<=t[r][1])&&t[r-1][2]!==null&&(t[r][2]===null&&t[r-1][2]!==null?t[r-1][2]=null:t[r-1][2]!=null?+s.mergeType==2&&t[r-1][0]===t[r][0]?t[r-1][2]=t[r][2]:t[r-1][2]+=t[r][2]:t[r-1][2]=t[r][2]),t.splice(r,1),r=t.length);return t.length?t:null}function E(e){return e!=null}function M(e){return Number.isInteger(e)&&e>=0}function R(e){return typeof e=="string"}var ve={limitToBeAddedWhitespace:!1,limitLinebreaksCount:1,mergeType:1},V=class{constructor(e){J(this,"ranges");J(this,"opts");let n=d(d({},ve),e);if(n.mergeType&&n.mergeType!==1&&n.mergeType!==2)if(R(n.mergeType)&&n.mergeType.trim()==="1")n.mergeType=1;else if(R(n.mergeType)&&n.mergeType.trim()==="2")n.mergeType=2;else throw new Error(`ranges-push: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "${typeof n.mergeType}", equal to ${JSON.stringify(n.mergeType,null,4)}`);this.opts=n,this.ranges=[]}add(e,n,i){if(e==null&&n==null)return;if(E(e)&&!E(n)){if(Array.isArray(e)){if(e.length){if(e.some(t=>Array.isArray(t))){e.forEach(t=>{Array.isArray(t)&&this.add(...t)});return}e.length&&M(+e[0])&&M(+e[1])&&this.add(...e)}return}throw new TypeError(`ranges-push/Ranges/add(): [THROW_ID_12] the first input argument, "from" is set (${JSON.stringify(e,null,0)}) but second-one, "to" is not (${JSON.stringify(n,null,0)})`)}else if(!E(e)&&E(n))throw new TypeError(`ranges-push/Ranges/add(): [THROW_ID_13] the second input argument, "to" is set (${JSON.stringify(n,null,0)}) but first-one, "from" is not (${JSON.stringify(e,null,0)})`);let s=+e,u=+n;if(M(i)&&(i=String(i)),M(s)&&M(u)){if(E(i)&&!R(i)&&!M(i))throw new TypeError(`ranges-push/Ranges/add(): [THROW_ID_08] The third argument, the value to add, was given not as string but ${typeof i}, equal to:
${JSON.stringify(i,null,4)}`);if(E(this.ranges)&&Array.isArray(this.last())&&s===this.last()[1]){if(this.last()[1]=u,this.last()[2],this.last()[2]!==null&&E(i)){let t=this.last()[2]&&this.last()[2].length>0&&(!this.opts||!this.opts.mergeType||this.opts.mergeType===1)?`${this.last()[2]}${i}`:i;this.opts.limitToBeAddedWhitespace&&(t=k(t,this.opts.limitLinebreaksCount)),R(t)&&!t.length||(this.last()[2]=t)}}else{this.ranges||(this.ranges=[]);let t=i!==void 0&&!(R(i)&&!i.length)?[s,u,i&&this.opts.limitToBeAddedWhitespace?k(i,this.opts.limitLinebreaksCount):i]:[s,u];this.ranges.push(t)}}else throw M(s)&&s>=0?new TypeError(`ranges-push/Ranges/add(): [THROW_ID_10] "to" value, the second input argument, must be a natural number or zero! Currently it's of a type "${typeof u}" equal to: ${JSON.stringify(u,null,4)}`):new TypeError(`ranges-push/Ranges/add(): [THROW_ID_09] "from" value, the first input argument, must be a natural number or zero! Currently it's of a type "${typeof s}" equal to: ${JSON.stringify(s,null,4)}`)}push(e,n,i){this.add(e,n,i)}current(){return Array.isArray(this.ranges)&&this.ranges.length?(this.ranges=Re(this.ranges,{mergeType:this.opts.mergeType}),this.ranges&&this.opts.limitToBeAddedWhitespace?this.ranges.map(e=>E(e[2])?[e[0],e[1],k(e[2],this.opts.limitLinebreaksCount)]:e):this.ranges):null}wipe(){this.ranges=[]}replace(e){if(Array.isArray(e)&&e.length)if(Array.isArray(e[0])&&M(e[0][0]))this.ranges=Array.from(e);else throw new Error(`ranges-push/Ranges/replace(): [THROW_ID_11] Single range was given but we expected array of arrays! The first element, ${JSON.stringify(e[0],null,4)} should be an array and its first element should be an integer, a string index.`);else this.ranges=[]}last(){return Array.isArray(this.ranges)&&this.ranges.length?this.ranges[this.ranges.length-1]:null}};var Se={strictlyTwoElementsInRangeArrays:!1,progressFn:null};function H(e,n){if(!Array.isArray(e)||!e.length)return e;let i=d(d({},Se),n),s,u;if(i.strictlyTwoElementsInRangeArrays&&!e.every((o,l)=>!Array.isArray(o)||o.length!==2?(s=l,u=o.length,!1):!0))throw new TypeError(`ranges-sort: [THROW_ID_03] The first argument should be an array and must consist of arrays which are natural number indexes representing TWO string index ranges. However, ${s}th range (${JSON.stringify(e[s],null,4)}) has not two but ${u} elements!`);if(!e.every((o,l)=>!Array.isArray(o)||!Number.isInteger(o[0])||o[0]<0||!Number.isInteger(o[1])||o[1]<0?(s=l,!1):!0))throw new TypeError(`ranges-sort: [THROW_ID_04] The first argument should be an array and must consist of arrays which are natural number indexes representing string index ranges. However, ${s}th range (${JSON.stringify(e[s],null,4)}) does not consist of only natural numbers!`);let t=e.length**2,a=0;return Array.from(e).sort((o,l)=>(i.progressFn&&(a+=1,i.progressFn(Math.floor(a*100/t))),o[0]===l[0]?o[1]<l[1]?-1:o[1]>l[1]?1:0:o[0]<l[0]?-1:1))}var Z={mergeType:1,progressFn:null,joinRangesThatTouchEdges:!0};function ee(e,n){function i(r){return r&&typeof r=="object"&&!Array.isArray(r)}if(!Array.isArray(e)||!e.length)return null;let s;if(n)if(i(n)){if(s=d(d({},Z),n),s.progressFn&&i(s.progressFn)&&!Object.keys(s.progressFn).length)s.progressFn=null;else if(s.progressFn&&typeof s.progressFn!="function")throw new Error(`ranges-merge: [THROW_ID_01] opts.progressFn must be a function! It was given of a type: "${typeof s.progressFn}", equal to ${JSON.stringify(s.progressFn,null,4)}`);if(![1,2,"1","2"].includes(s.mergeType))throw new Error(`ranges-merge: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "${typeof s.mergeType}", equal to ${JSON.stringify(s.mergeType,null,4)}`);if(typeof s.joinRangesThatTouchEdges!="boolean")throw new Error(`ranges-merge: [THROW_ID_04] opts.joinRangesThatTouchEdges was customised to a wrong thing! It was given of a type: "${typeof s.joinRangesThatTouchEdges}", equal to ${JSON.stringify(s.joinRangesThatTouchEdges,null,4)}`)}else throw new Error(`emlint: [THROW_ID_03] the second input argument must be a plain object. It was given as:
${JSON.stringify(n,null,4)} (type ${typeof n})`);else s=d({},Z);let u=e.filter(r=>Array.isArray(r)).map(r=>[...r]).filter(r=>r[2]!==void 0||r[0]!==r[1]),t,a,o;s.progressFn?t=H(u,{progressFn:r=>{o=Math.floor(r/5),o!==a&&(a=o,s.progressFn(o))}}):t=H(u);let l=t.length-1;for(let r=l;r>0;r--)s.progressFn&&(o=Math.floor((1-r/l)*78)+21,o!==a&&o>a&&(a=o,s.progressFn(o))),(t[r][0]<=t[r-1][0]||!s.joinRangesThatTouchEdges&&t[r][0]<t[r-1][1]||s.joinRangesThatTouchEdges&&t[r][0]<=t[r-1][1])&&(t[r-1][0]=Math.min(t[r][0],t[r-1][0]),t[r-1][1]=Math.max(t[r][1],t[r-1][1]),t[r][2]!==void 0&&(t[r-1][0]>=t[r][0]||t[r-1][1]<=t[r][1])&&t[r-1][2]!==null&&(t[r][2]===null&&t[r-1][2]!==null?t[r-1][2]=null:t[r-1][2]!=null?+s.mergeType==2&&t[r-1][0]===t[r][0]?t[r-1][2]=t[r][2]:t[r-1][2]+=t[r][2]:t[r-1][2]=t[r][2]),t.splice(r,1),r=t.length);return t.length?t:null}var _e=!0,W="Invariant failed";function te(e,n){if(!e){if(_e)throw new Error(W);var i=typeof n=="function"?n():n,s=i?W+": "+i:W;throw new Error(s)}}function re(e,n,i){let s=0,u=0;if(arguments.length===0)throw new Error("ranges-apply: [THROW_ID_01] inputs missing!");if(typeof e!="string")throw new TypeError(`ranges-apply: [THROW_ID_02] first input argument must be a string! Currently it's: ${typeof e}, equal to: ${JSON.stringify(e,null,4)}`);if(n&&!Array.isArray(n))throw new TypeError(`ranges-apply: [THROW_ID_03] second input argument must be an array (or null)! Currently it's: ${typeof n}, equal to: ${JSON.stringify(n,null,4)}`);if(i&&typeof i!="function")throw new TypeError(`ranges-apply: [THROW_ID_04] the third input argument must be a function (or falsey)! Currently it's: ${typeof i}, equal to: ${JSON.stringify(i,null,4)}`);if(!n||!n.filter(g=>g).length)return e;let t;Array.isArray(n)&&Number.isInteger(n[0])&&Number.isInteger(n[1])?t=[Array.from(n)]:t=Array.from(n);let a=t.length,o=0;t.filter(g=>g).forEach((g,f)=>{if(i&&(s=Math.floor(o/a*10),s!==u&&(u=s,i(s))),!Array.isArray(g))throw new TypeError(`ranges-apply: [THROW_ID_05] ranges array, second input arg., has ${f}th element not an array: ${JSON.stringify(g,null,4)}, which is ${typeof g}`);if(!Number.isInteger(g[0])){if(!Number.isInteger(+g[0])||+g[0]<0)throw new TypeError(`ranges-apply: [THROW_ID_06] ranges array, second input arg. has ${f}th element, array ${JSON.stringify(g,null,0)}. Its first element is not an integer, string index, but ${typeof g[0]}, equal to: ${JSON.stringify(g[0],null,4)}.`);t[f][0]=+t[f][0]}if(!Number.isInteger(g[1])){if(!Number.isInteger(+g[1])||+g[1]<0)throw new TypeError(`ranges-apply: [THROW_ID_07] ranges array, second input arg. has ${f}th element, array ${JSON.stringify(g,null,0)}. Its second element is not an integer, string index, but ${typeof g[1]}, equal to: ${JSON.stringify(g[1],null,4)}.`);t[f][1]=+t[f][1]}o+=1});let l=ee(t,{progressFn:g=>{i&&(s=10+Math.floor(g/10),s!==u&&(u=s,i(s)))}});te(l);let r=l.length;if(r>0){let g=e.slice(l[r-1][1]);e=l.reduce((f,y,m,c)=>{i&&(s=20+Math.floor(m/r*80),s!==u&&(u=s,i(s)));let h=m===0?0:c[m-1][1],$=c[m][0];return`${f}${e.slice(h,$)}${c[m][2]||""}`},""),e+=g}return e}var Fe={classicTrim:!1,cr:!1,lf:!1,tab:!1,space:!0,nbsp:!1};function v(e,n){if(typeof e!="string")throw new Error(`string-trim-spaces-only: [THROW_ID_01] input must be string! It was given as ${typeof e}, equal to:
${JSON.stringify(e,null,4)}`);let i=d(d({},Fe),n);function s(a){return i.classicTrim&&!a.trim()||!i.classicTrim&&(i.space&&a===" "||i.cr&&a==="\r"||i.lf&&a===`
`||i.tab&&a==="	"||i.nbsp&&a==="\xA0")}let u,t;if(e.length){if(s(e[0]))for(let a=0,o=e.length;a<o;a++){if(!s(e[a])){u=a;break}if(a===e.length-1)return{res:"",ranges:[[0,e.length]]}}if(s(e[e.length-1])){for(let a=e.length;a--;)if(!s(e[a])){t=a+1;break}}return u?t?{res:e.slice(u,t),ranges:[[0,u],[t,e.length]]}:{res:e.slice(u),ranges:[[0,u]]}:t?{res:e.slice(0,t),ranges:[[t,e.length]]}:{res:e,ranges:[]}}return{res:"",ranges:[]}}var ne="6.0.12";var Ce=ne,ie={heads:["{{"],tails:["}}"]};function Je(e,n){let i=Object.prototype.hasOwnProperty;if(e===void 0)throw new Error("string-remove-duplicate-heads-tails: [THROW_ID_01] The input is missing!");if(typeof e!="string")return e;if(n&&!(0,se.default)(n))throw new Error(`string-remove-duplicate-heads-tails: [THROW_ID_03] The given options are not a plain object but ${typeof n}!`);let s=d({},n);if(s&&i.call(s,"heads"))if(N(s.heads).every(h=>typeof h=="string"||Array.isArray(h)))typeof s.heads=="string"&&(s.heads=N(s.heads));else throw new Error("string-remove-duplicate-heads-tails: [THROW_ID_04] The opts.heads contains elements which are not string-type!");if(s&&i.call(s,"tails"))if(N(s.tails).every(h=>typeof h=="string"||Array.isArray(h)))typeof s.tails=="string"&&(s.tails=N(s.tails));else throw new Error("string-remove-duplicate-heads-tails: [THROW_ID_05] The opts.tails contains elements which are not string-type!");let u=v(e).res;if(u.length===0)return e;e=u;let t=d(d({},ie),s);t.heads=t.heads.map(h=>h.trim()),t.tails=t.tails.map(h=>h.trim());let a=!1,o=!1,l=new V({limitToBeAddedWhitespace:!0}),r=new V({limitToBeAddedWhitespace:!0}),g=!0,f=!0,y="";function m(h,$){let p;return I(h,0,$.heads,{trimBeforeMatching:!0,cb:(w,T,b)=>(p=b,!0)})&&I(h,p,$.tails,{trimBeforeMatching:!0,cb:(w,T,b)=>(p=b,!0)})?h.slice(p):h}for(;e!==m(e,t);)e=v(m(e,t)).res;function c(h,$){let p;return!F(h,h.length-1,$.tails,{trimBeforeMatching:!0,cb:(w,T,b)=>(p=b,!0)})||!p?h:F(h,p,$.heads,{trimBeforeMatching:!0,cb:(w,T,b)=>(p=b,!0)})?h.slice(0,p+1):h}for(;e!==c(e,t);)e=v(c(e,t)).res;if(!t.heads.length||!I(e,0,t.heads,{trimBeforeMatching:!0})||!t.tails.length||!F(e,e.length-1,t.tails,{trimBeforeMatching:!0}))return v(e).res;for(let h=0,$=e.length;h<$;h++)if(e[h].trim()!==""){let p;if(I(e,h,t.heads,{trimBeforeMatching:!0,cb:(w,T,b)=>(p=b,!0)})&&p){f=!0,g&&(g=!0);let w;I(e,p,t.tails,{trimBeforeMatching:!0,cb:(b,S,oe)=>(w=oe,!0)})&&l.push(h,w),r.current()&&a&&y!=="tails"&&l.push(r.current()),a||r.current()&&(l.push(r.current()),r.wipe()),r.push(h,p),y="heads",h=p-1;continue}if(I(e,h,t.tails,{trimBeforeMatching:!0,cb:(w,T,b)=>(p=Number.isInteger(b)?b:e.length,!0)})&&p){f=!0,g?(y==="heads"&&r.wipe(),g=!1):r.push(h,p),y="tails",h=p-1;continue}g&&(g=!0),f&&!a?(a=!0,f=!1):f&&!o?(o=!0,g=!0,f=!1,y==="heads"&&r.wipe()):f&&o&&r.wipe()}return r.current()&&l.push(r.current()),l.current()?re(e,l.current()).trim():e.trim()}return pe(Ve);})();
/**
 * @name arrayiffy-if-string
 * @fileoverview Put non-empty strings into arrays, turn empty-ones into empty arrays. Bypass everything else.
 * @version 4.0.12
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/arrayiffy-if-string/}
 */
/**
 * @name ranges-apply
 * @fileoverview Take an array of string index ranges, delete/replace the string according to them
 * @version 6.0.12
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-apply/}
 */
/**
 * @name ranges-merge
 * @fileoverview Merge and sort string index ranges
 * @version 8.0.12
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-merge/}
 */
/**
 * @name ranges-push
 * @fileoverview Gather string index ranges
 * @version 6.0.12
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-push/}
 */
/**
 * @name ranges-sort
 * @fileoverview Sort string index ranges
 * @version 5.0.12
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-sort/}
 */
/**
 * @name string-collapse-leading-whitespace
 * @fileoverview Collapse the leading and trailing whitespace of a string
 * @version 6.0.12
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/string-collapse-leading-whitespace/}
 */
/**
 * @name string-match-left-right
 * @fileoverview Match substrings on the left or right of a given index, ignoring whitespace
 * @version 8.0.12
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/string-match-left-right/}
 */
/**
 * @name string-trim-spaces-only
 * @fileoverview Like String.trim() but you can choose granularly what to trim
 * @version 4.0.12
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/string-trim-spaces-only/}
 */
