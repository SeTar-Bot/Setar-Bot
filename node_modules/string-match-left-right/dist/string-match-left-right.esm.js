/**
 * @name string-match-left-right
 * @fileoverview Match substrings on the left or right of a given index, ignoring whitespace
 * @version 8.0.12
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/string-match-left-right/}
 */

import{arrayiffy as S}from"arrayiffy-if-string";function p(t){return t&&typeof t=="object"&&!Array.isArray(t)}function M(t){return typeof t=="string"}var R={cb:void 0,i:!1,trimBeforeMatching:!1,trimCharsBeforeMatching:[],maxMismatches:0,firstMustMatch:!1,lastMustMatch:!1,hungry:!1},w=t=>t+1;function N(t,a,n,s,h=!1,o=w){let l=typeof n=="function"?n():n;if(+a<0&&h&&l==="EOL")return l;let r={...R,...s};if(a>=t.length&&!h)return!1;let c=h?1:n.length,E=0,u=!1,i=!1,m=!1,b=r.maxMismatches,e=a,g=!1,f=!1,$=!1;function T(){return E===1&&b<r.maxMismatches-1}for(;t[e];){let V=o(e);if(r.trimBeforeMatching&&t[e].trim()===""){if(!t[V]&&h&&n==="EOL")return!0;e=o(e);continue}if(r&&!r.i&&r.trimCharsBeforeMatching&&r.trimCharsBeforeMatching.includes(t[e])||r?.i&&r.trimCharsBeforeMatching&&r.trimCharsBeforeMatching.map(D=>D.toLowerCase()).includes(t[e].toLowerCase())){if(h&&n==="EOL"&&!t[V])return!0;e=o(e);continue}let d=V>e?n[n.length-c]:n[c-1];if(!r.i&&t[e]===d||r.i&&t[e].toLowerCase()===d.toLowerCase()){if(g||(g=!0),m||(m=!0),c===n.length){if(f=!0,b!==r.maxMismatches)return!1}else c===1&&($=!0);if(c-=1,E++,T())return!1;if(!c)return E!==n.length||b===r.maxMismatches||!u?e:!1}else if(!u&&!E&&(u=!0),r.maxMismatches&&b&&e){b-=1;for(let D=0;D<=b;D++){let C=V>e?n[n.length-c+1+D]:n[c-2-D],O=t[o(e)];if(C&&(!r.i&&t[e]===C||r.i&&t[e].toLowerCase()===C.toLowerCase())&&(!r.firstMustMatch||c!==n.length)){if(E++,T())return!1;c-=2,g=!0;break}else if(O&&C&&(!r.i&&O===C||r.i&&O.toLowerCase()===C.toLowerCase())&&(!r.firstMustMatch||c!==n.length)){if(!E&&!r.hungry)return!1;c-=1,g=!0;break}else if(C===void 0&&b>=0&&g&&(!r.firstMustMatch||f)&&(!r.lastMustMatch||$))return e}g||(i=e)}else return e===0&&c===1&&!r.lastMustMatch&&m?0:!1;if(i!==!1&&i!==e&&(i=!1),c<1)return e;e=o(e)}if(c>0)return h&&l==="EOL"?!0:r&&r.maxMismatches>=c&&m?i||0:!1}function y(t,a,n,s,h){if(p(h)&&Object.prototype.hasOwnProperty.call(h,"trimBeforeMatching")&&typeof h.trimBeforeMatching!="boolean")throw new Error(`string-match-left-right/${t}(): [THROW_ID_09] opts.trimBeforeMatching should be boolean!${Array.isArray(h.trimBeforeMatching)?" Did you mean to use opts.trimCharsBeforeMatching?":""}`);let o={...R,...h};if(typeof o.trimCharsBeforeMatching=="string"&&(o.trimCharsBeforeMatching=S(o.trimCharsBeforeMatching)),o.trimCharsBeforeMatching=o.trimCharsBeforeMatching.map(u=>M(u)?u:String(u)),!M(a)||!a.length)return!1;if(!Number.isInteger(n)||n<0)throw new Error(`string-match-left-right/${t}(): [THROW_ID_03] the second argument should be a natural number. Currently it's of a type: ${typeof n}, equal to:
${JSON.stringify(n,null,4)}`);let l,r;if(M(s))l=[s];else if(Array.isArray(s))l=s;else if(!s)l=s;else if(typeof s=="function")l=[],l.push(s);else throw new Error(`string-match-left-right/${t}(): [THROW_ID_05] the third argument, whatToMatch, is neither string nor array of strings! It's ${typeof s}, equal to:
${JSON.stringify(s,null,4)}`);if(h&&!p(h))throw new Error(`string-match-left-right/${t}(): [THROW_ID_06] the fourth argument, options object, should be a plain object. Currently it's of a type "${typeof h}", and equal to:
${JSON.stringify(h,null,4)}`);let c=0,E="";if(o?.trimCharsBeforeMatching&&o.trimCharsBeforeMatching.some((u,i)=>u.length>1?(c=i,E=u,!0):!1))throw new Error(`string-match-left-right/${t}(): [THROW_ID_07] the fourth argument, options object contains trimCharsBeforeMatching. It was meant to list the single characters but one of the entries at index ${c} is longer than 1 character, ${E.length} (equals to ${E}). Please split it into separate characters and put into array as separate elements.`);if(!l||!Array.isArray(l)||Array.isArray(l)&&!l.length||Array.isArray(l)&&l.length===1&&M(l[0])&&!l[0].trim()){if(typeof o.cb=="function"){let i,m=n;if((t==="matchLeftIncl"||t==="matchRight")&&(m+=1),t[5]==="L")for(let f=m;f--;){let $=a[f];if((!o.trimBeforeMatching||o.trimBeforeMatching&&$!==void 0&&$.trim())&&(!o.trimCharsBeforeMatching||!o.trimCharsBeforeMatching.length||$!==void 0&&!o.trimCharsBeforeMatching.includes($))){i=f;break}}else if(t.startsWith("matchRight"))for(let f=m;f<a.length;f++){let $=a[f];if((!o.trimBeforeMatching||o.trimBeforeMatching&&$.trim())&&(!o.trimCharsBeforeMatching||!o.trimCharsBeforeMatching.length||!o.trimCharsBeforeMatching.includes($))){i=f;break}}if(i===void 0)return!1;let b=a[i],e=i+1,g="";return e&&e>0&&(g=a.slice(0,e)),t[5]==="L"||i&&i>0&&(g=a.slice(i)),o.cb(b,g,i)}let u="";throw h||(u=" More so, the whole options object, the fourth input argument, is missing!"),new Error(`string-match-left-right/${t}(): [THROW_ID_08] the third argument, "whatToMatch", was given as an empty string. This means, you intend to match purely by a callback. The callback was not set though, the opts key "cb" is not set!${u}`)}for(let u=0,i=l.length;u<i;u++){r=typeof l[u]=="function";let m=l[u],b,e,g="",f=n;t==="matchRight"?f+=1:t==="matchLeft"&&(f-=1);let $=N(a,f,m,o,r,T=>t[5]==="L"?T-1:T+1);if($&&r&&typeof m=="function"&&m()==="EOL")return m()&&(o.cb?o.cb(b,g,e):!0)?m():!1;if(Number.isInteger($)&&(e=t.startsWith("matchLeft")?$-1:$+1,t[5]==="L"?g=a.slice(0,$):g=a.slice(e)),e<0&&(e=void 0),a[e]&&(b=a[e]),Number.isInteger($)&&(o.cb?o.cb(b,g,e):!0))return m}return!1}function A(t,a,n,s){return y("matchLeftIncl",t,a,n,s)}function k(t,a,n,s){return y("matchLeft",t,a,n,s)}function B(t,a,n,s){return y("matchRightIncl",t,a,n,s)}function I(t,a,n,s){return y("matchRight",t,a,n,s)}export{k as matchLeft,A as matchLeftIncl,I as matchRight,B as matchRightIncl};
