/**
 * @name string-match-left-right
 * @fileoverview Match substrings on the left or right of a given index, ignoring whitespace
 * @version 8.0.12
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/string-match-left-right/}
 */

var stringMatchLeftRight=(()=>{var y=Object.defineProperty;var B=Object.getOwnPropertyDescriptor;var I=Object.getOwnPropertyNames,S=Object.getOwnPropertySymbols;var w=Object.prototype.hasOwnProperty,J=Object.prototype.propertyIsEnumerable;var N=(t,n,e)=>n in t?y(t,n,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[n]=e,V=(t,n)=>{for(var e in n||(n={}))w.call(n,e)&&N(t,e,n[e]);if(S)for(var e of S(n))J.call(n,e)&&N(t,e,n[e]);return t};var x=t=>y(t,"__esModule",{value:!0});var F=(t,n)=>{for(var e in n)y(t,e,{get:n[e],enumerable:!0})},H=(t,n,e,s)=>{if(n&&typeof n=="object"||typeof n=="function")for(let l of I(n))!w.call(t,l)&&(e||l!=="default")&&y(t,l,{get:()=>n[l],enumerable:!(s=B(n,l))||s.enumerable});return t};var P=(t=>(n,e)=>t&&t.get(n)||(e=H(x({}),n,1),t&&t.set(n,e),e))(typeof WeakMap!="undefined"?new WeakMap:0);var G={};F(G,{matchLeft:()=>_,matchLeftIncl:()=>W,matchRight:()=>Y,matchRightIncl:()=>q});function L(t){return typeof t=="string"?t.length?[t]:[]:t}function A(t){return t&&typeof t=="object"&&!Array.isArray(t)}function O(t){return typeof t=="string"}var k={cb:void 0,i:!1,trimBeforeMatching:!1,trimCharsBeforeMatching:[],maxMismatches:0,firstMustMatch:!1,lastMustMatch:!1,hungry:!1},U=t=>t+1;function j(t,n,e,s,l=!1,r=U){var K;let i=typeof e=="function"?e():e;if(+n<0&&l&&i==="EOL")return i;let a=V(V({},k),s);if(n>=t.length&&!l)return!1;let u=l?1:e.length,E=0,h=!1,c=!1,m=!1,b=a.maxMismatches,o=n,g=!1,f=!1,$=!1;function T(){return E===1&&b<a.maxMismatches-1}for(;t[o];){let M=r(o);if(a.trimBeforeMatching&&t[o].trim()===""){if(!t[M]&&l&&e==="EOL")return!0;o=r(o);continue}if(a&&!a.i&&a.trimCharsBeforeMatching&&a.trimCharsBeforeMatching.includes(t[o])||(a==null?void 0:a.i)&&a.trimCharsBeforeMatching&&a.trimCharsBeforeMatching.map(D=>D.toLowerCase()).includes(t[o].toLowerCase())){if(l&&e==="EOL"&&!t[M])return!0;o=r(o);continue}let R=M>o?e[e.length-u]:e[u-1];if(!a.i&&t[o]===R||a.i&&t[o].toLowerCase()===R.toLowerCase()){if(g||(g=!0),m||(m=!0),u===e.length){if(f=!0,b!==a.maxMismatches)return!1}else u===1&&($=!0);if(u-=1,E++,T())return!1;if(!u)return E!==e.length||b===a.maxMismatches||!h?o:!1}else if(!h&&!E&&(h=!0),a.maxMismatches&&b&&o){b-=1;for(let D=0;D<=b;D++){let C=M>o?e[e.length-u+1+D]:e[u-2-D],p=t[r(o)];if(C&&(!a.i&&t[o]===C||a.i&&t[o].toLowerCase()===C.toLowerCase())&&(!a.firstMustMatch||u!==e.length)){if(E++,T())return!1;u-=2,g=!0;break}else if(p&&C&&(!a.i&&p===C||a.i&&p.toLowerCase()===C.toLowerCase())&&(!a.firstMustMatch||u!==e.length)){if(!E&&!a.hungry)return!1;u-=1,g=!0;break}else if(C===void 0&&b>=0&&g&&(!a.firstMustMatch||f)&&(!a.lastMustMatch||$))return o}g||(c=o)}else return o===0&&u===1&&!a.lastMustMatch&&m?0:!1;if(c!==!1&&c!==o&&(c=!1),u<1)return o;o=r(o)}if(u>0)return l&&i==="EOL"?!0:a&&a.maxMismatches>=u&&m?c||0:!1}function d(t,n,e,s,l){if(A(l)&&Object.prototype.hasOwnProperty.call(l,"trimBeforeMatching")&&typeof l.trimBeforeMatching!="boolean")throw new Error(`string-match-left-right/${t}(): [THROW_ID_09] opts.trimBeforeMatching should be boolean!${Array.isArray(l.trimBeforeMatching)?" Did you mean to use opts.trimCharsBeforeMatching?":""}`);let r=V(V({},k),l);if(typeof r.trimCharsBeforeMatching=="string"&&(r.trimCharsBeforeMatching=L(r.trimCharsBeforeMatching)),r.trimCharsBeforeMatching=r.trimCharsBeforeMatching.map(h=>O(h)?h:String(h)),!O(n)||!n.length)return!1;if(!Number.isInteger(e)||e<0)throw new Error(`string-match-left-right/${t}(): [THROW_ID_03] the second argument should be a natural number. Currently it's of a type: ${typeof e}, equal to:
${JSON.stringify(e,null,4)}`);let i,a;if(O(s))i=[s];else if(Array.isArray(s))i=s;else if(!s)i=s;else if(typeof s=="function")i=[],i.push(s);else throw new Error(`string-match-left-right/${t}(): [THROW_ID_05] the third argument, whatToMatch, is neither string nor array of strings! It's ${typeof s}, equal to:
${JSON.stringify(s,null,4)}`);if(l&&!A(l))throw new Error(`string-match-left-right/${t}(): [THROW_ID_06] the fourth argument, options object, should be a plain object. Currently it's of a type "${typeof l}", and equal to:
${JSON.stringify(l,null,4)}`);let u=0,E="";if((r==null?void 0:r.trimCharsBeforeMatching)&&r.trimCharsBeforeMatching.some((h,c)=>h.length>1?(u=c,E=h,!0):!1))throw new Error(`string-match-left-right/${t}(): [THROW_ID_07] the fourth argument, options object contains trimCharsBeforeMatching. It was meant to list the single characters but one of the entries at index ${u} is longer than 1 character, ${E.length} (equals to ${E}). Please split it into separate characters and put into array as separate elements.`);if(!i||!Array.isArray(i)||Array.isArray(i)&&!i.length||Array.isArray(i)&&i.length===1&&O(i[0])&&!i[0].trim()){if(typeof r.cb=="function"){let c,m=e;if((t==="matchLeftIncl"||t==="matchRight")&&(m+=1),t[5]==="L")for(let f=m;f--;){let $=n[f];if((!r.trimBeforeMatching||r.trimBeforeMatching&&$!==void 0&&$.trim())&&(!r.trimCharsBeforeMatching||!r.trimCharsBeforeMatching.length||$!==void 0&&!r.trimCharsBeforeMatching.includes($))){c=f;break}}else if(t.startsWith("matchRight"))for(let f=m;f<n.length;f++){let $=n[f];if((!r.trimBeforeMatching||r.trimBeforeMatching&&$.trim())&&(!r.trimCharsBeforeMatching||!r.trimCharsBeforeMatching.length||!r.trimCharsBeforeMatching.includes($))){c=f;break}}if(c===void 0)return!1;let b=n[c],o=c+1,g="";return o&&o>0&&(g=n.slice(0,o)),t[5]==="L"||c&&c>0&&(g=n.slice(c)),r.cb(b,g,c)}let h="";throw l||(h=" More so, the whole options object, the fourth input argument, is missing!"),new Error(`string-match-left-right/${t}(): [THROW_ID_08] the third argument, "whatToMatch", was given as an empty string. This means, you intend to match purely by a callback. The callback was not set though, the opts key "cb" is not set!${h}`)}for(let h=0,c=i.length;h<c;h++){a=typeof i[h]=="function";let m=i[h],b,o,g="",f=e;t==="matchRight"?f+=1:t==="matchLeft"&&(f-=1);let $=j(n,f,m,r,a,T=>t[5]==="L"?T-1:T+1);if($&&a&&typeof m=="function"&&m()==="EOL")return m()&&(r.cb?r.cb(b,g,o):!0)?m():!1;if(Number.isInteger($)&&(o=t.startsWith("matchLeft")?$-1:$+1,t[5]==="L"?g=n.slice(0,$):g=n.slice(o)),o<0&&(o=void 0),n[o]&&(b=n[o]),Number.isInteger($)&&(r.cb?r.cb(b,g,o):!0))return m}return!1}function W(t,n,e,s){return d("matchLeftIncl",t,n,e,s)}function _(t,n,e,s){return d("matchLeft",t,n,e,s)}function q(t,n,e,s){return d("matchRightIncl",t,n,e,s)}function Y(t,n,e,s){return d("matchRight",t,n,e,s)}return P(G);})();
/**
 * @name arrayiffy-if-string
 * @fileoverview Put non-empty strings into arrays, turn empty-ones into empty arrays. Bypass everything else.
 * @version 4.0.12
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/arrayiffy-if-string/}
 */
